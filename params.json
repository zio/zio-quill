{"name":"Quill","tagline":"Compile-time Language Integrated Query for Scala","body":"\r\nQuill provides a Quoted Domain Specific Language ([QDSL](http://homepages.inf.ed.ac.uk/slindley/papers/qdsl-draft-february2015.pdf)) to express queries in Scala and execute them in a target language. The library's core is designed to support multiple target languages, currently featuring specializations for Structured Query Language ([SQL](https://en.wikipedia.org/wiki/SQL)) and Cassandra Query Language ([CQL](https://cassandra.apache.org/doc/cql3/CQL.html#selectStmt)).\r\n\r\n![example](https://raw.githubusercontent.com/getquill/quill/master/example.gif)\r\n\r\n1. **Boilerplate-free mapping**: The database schema is mapped using simple case classes.\r\n2. **Quoted DSL**: Queries are defined inside a `quote` block. Quill parses each quoted block of code (quotation) at compile time and translates them to an internal Abstract Syntax Tree (AST)\r\n3. **Compile-time query generation**: The `db.run` call reads the quotation's AST and translates it to the target language at compile time, emitting the query string as a compilation message. As the query string is known at compile time, the runtime overhead is very low and similar to using the database driver directly.\r\n4. **Compile-time query validation**: If configured, the query is verified against the database at compile time and the compilation fails if it is not valid. The query validation **does not** alter the database state.\r\n\r\n# Index #\r\n\r\n* [Quotation](#quotation)\r\n* [Mirror sources](#mirror-sources)\r\n* [Compile-time quotations](#compile-time-quotations)\r\n* [Parametrized quotations](#parametrized-quotations)\r\n* [Schema](#schema)\r\n* [Queries](#queries)\r\n* [Query probing](#query-probing)\r\n* [Actions](#actions)\r\n* [Dynamic queries](#dynamic-queries)\r\n* [SQL-specific operations](#sql-specific-operations)\r\n* [Cassandra-specific operations](#cassandra-specific-operations)\r\n* [Extending quill](#extending-quill)\r\n  * [Infix](#infix)\r\n  * [Custom encoding](#custom-encoding)\r\n* [Sql Sources](#sql-sources)\r\n  * [Dialect](#dialect)\r\n  * [Naming strategy](#naming-strategy)\r\n  * [Configuration](#configuration)\r\n* [Cassandra sources](#cassandra-sources)\r\n* [Acknowledgments](#acknowledgments)\r\n* [License](#license)\r\n\r\n# Quotation #\r\n\r\nThe QDSL allows the user to write plain Scala code, leveraging scala's syntax and type system. Quotations are created using the `quote` method and can contain any excerpt of code that uses supported operations. To create quotations, first import `quote` and some other auxiliary methods:\r\n\r\n```scala\r\nimport io.getquill._\r\n```\r\n\r\nA quotation can be a simple value:\r\n\r\n```scala\r\nval pi = quote(3.14159)\r\n```\r\n\r\nAnd be used within another quotation:\r\n\r\n```scala\r\ncase class Circle(radius: Float)\r\n\r\nval areas = quote {\r\n  query[Circle].map(c => pi * c.radius * c.radius)\r\n}\r\n```\r\n\r\nQuotations can also contain high-order functions:\r\n\r\n```scala\r\nval area = quote {\r\n  (c: Circle) => pi * c.radius * c.radius\r\n}\r\n```\r\n\r\n```scala\r\nval areas = quote {\r\n  query[Circle].map(c => area(c))\r\n}\r\n```\r\n\r\nQuill's normalization engine applies reduction steps before translating the quotation to the target language. The correspondent normalized quotation for both versions of the `areas` query is:\r\n\r\n```scala\r\nval areas = quote {\r\n  query[Circle].map(c => 3.14159 * c.radius * c.radius)\r\n}\r\n```\r\n\r\nScala doesn't have support for high-order functions with type parameters. Quill supports anonymous classes with an apply method for this purpose:\r\n\r\n```scala\r\nval existsAny = quote {\r\n  new {\r\n    def apply[T](xs: Query[T])(p: T => Boolean) =\r\n    \txs.filter(p(_)).nonEmpty\r\n  }\r\n}\r\n\r\nval q = quote {\r\n  query[Circle].filter { c1 => \r\n    existsAny(query[Circle])(c2 => c2.radius > c1.radius)\r\n  }\r\n}\r\n```\r\n\r\n# Mirror sources #\r\n\r\nSources represent the database and provide an execution interface for queries. Quill provides mirror sources for test purposes. Please refer to [sources](#sources) for information on how to create normal sources.\r\n\r\nInstead of running the query, mirror sources return a structure with the information that would be used to run the query. There are three mirror source configurations:\r\n\r\n- `io.getquill.MirrorSourceConfig`: Mirrors the quotation AST\r\n- `io.getquill.SqlMirrorSourceConfig`: Mirrors the SQL query\r\n- `io.getquill.CassandraMirrorSourceConfig`: Mirrors the CQL query\r\n\r\nThis documentation uses the SQL mirror in its examples under the `db` name:\r\n\r\n```scala\r\nimport io.getquill._\r\n\r\nlazy val db = source(new SqlMirrorSourceConfig(\"testSource\"))\r\n```\r\n\r\n# Compile-time quotations #\r\n\r\nQuotations are both compile-time and runtime values. Quill uses a type refinement to store the quotation's AST as an annotation available at compile-time and the `q.ast` method exposes the AST as runtime value.\r\n\r\nIt is important to avoid giving explicit types to quotations when possible. For instance, this quotation can't be read at compile-time as the type refinement is lost:\r\n\r\n```scala\r\nval q: Quoted[Query[Circle]] = quote {\r\n  query[Circle].filter(c => c.radius > 10)\r\n}\r\n\r\ndb.run(q) // Dynamic query\r\n```\r\n\r\nQuill falls back to runtime normalization and query generation if the quotation's AST can be read at compile-time. Please refer to [dynamic queries](#dynamic-queries) for more information\r\n\r\n# Parametrized quotations #\r\n\r\nQuotations are designed to be self-contained, without references to runtime values outside their scope. If a quotation needs to receive a runtime value, it needs to be done by defining the quotation as a function:\r\n\r\n```scala\r\nval q = quote {\r\n  (i: Int) =>\r\n    query[Circle].filter(r => r.radius > i)\r\n}\r\n```\r\n\r\nThe runtime value can be specified when running it:\r\n\r\n```scala\r\ndb.run(q)(10) // SELECT r.radius FROM Circle r WHERE r.radius > ?\r\n```\r\n\r\nThe method `run` is a bridge between the compile-time quotations and the runtime execution.\r\n\r\n# Schema #\r\n\r\nThe database schema is represented by case classes. By default, quill uses the class and field names as the database identifiers:\r\n\r\n```scala\r\ncase class Circle(radius: Float)\r\n\r\nval q = quote {\r\n  query[Circle].filter(c => c.radius > 1)\r\n}\r\n\r\ndb.run(q) // SELECT c.radius FROM Circle c WHERE c.radius > 1\r\n```\r\n\r\nAlternatively, the identifiers can be customized:\r\n\r\n```scala\r\nval circles = quote {\r\n  query[Circle](\"circle_table\", _.radius -> \"radius_column\")\r\n}\r\n\r\nval q = quote {\r\n  circles.filter(c => c.radius > 1)\r\n}\r\n\r\ndb.run(q) \r\n// SELECT c.radius_column FROM circle_table c WHERE c.radius_column > 1\r\n```\r\n\r\nIf multiple tables require custom identifiers, it is good practice to define a `schema` object with all table queries to be reused across multiple queries:\r\n\r\n```scala\r\ncase class Circle(radius: Int)\r\ncase class Rectangle(length: Int, width: Int)\r\nobject schema {\r\n  val circles = quote {\r\n    query[Circle](\"circle_table\", \r\n      _.radius -> \"radius_column\")\r\n  }\r\n  val rectangles = quote {\r\n    query[Rectangle](\"rectangle_table\", \r\n      _.length -> \"length_column\", \r\n      _.width -> \"width_column\")\r\n  }\r\n}\r\n```\r\n\r\n# Queries #\r\n\r\nThe overall abstraction of quill queries is use database tables as if they were in-memory collections. Scala for-comprehensions provide syntatic sugar to deal with this kind of monadic operations:\r\n\r\n```scala\r\ncase class Person(id: Int, name: String, age: Int)\r\ncase class Contact(personId: Int, phone: String)\r\n\r\nval q = quote {\r\n  for {\r\n    p <- query[Person] if(p.id == 999)\r\n    c <- query[Contact] if(c.personId == p.id)\r\n  } yield {\r\n    (p.name, c.phone)\r\n  }\r\n}\r\n\r\ndb.run(q) \r\n// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)\r\n```\r\n\r\nQuill normalizes the quotation and translates the monadic joins to applicative joins, generating a database-friendly query that avoids nested queries.\r\n\r\nAny of the following features can be used together with the others and/or within a for-comprehension:\r\n\r\n**filter**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => p.age > 18)\r\n}\r\n\r\ndb.run(q)\r\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.age > 18\r\n```\r\n\r\n**map**\r\n```scala\r\nval q = quote {\r\n  query[Person].map(p => p.name)\r\n}\r\n\r\ndb.run(q)\r\n// SELECT p.name FROM Person p\r\n```\r\n\r\n**flatMap**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => p.age > 18).flatMap(p => query[Contact].filter(c => c.personId == p.id))\r\n}\r\n\r\ndb.run(q)\r\n// SELECT c.personId, c.phone FROM Person p, Contact c WHERE (p.age > 18) AND (c.personId = p.id)\r\n```\r\n\r\n**sortBy**\r\n```scala\r\nval q1 = quote {\r\n  query[Person].sortBy(p => p.age)\r\n}\r\n\r\ndb.run(q1)\r\n// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age ASC NULLS FIRST\r\n\r\nval q2 = quote {\r\n  query[Person].sortBy(p => p.age)(Ord.descNullsLast)\r\n}\r\n\r\ndb.run(q2)\r\n// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.age DESC NULLS LAST\r\n\r\nval q3 = quote {\r\n  query[Person].sortBy(p => (p.name, p.age))(Ord(Ord.asc, Ord.desc))\r\n}\r\n\r\ndb.run(q3)\r\n// SELECT p.id, p.name, p.age FROM Person p ORDER BY p.name ASC, p.age DESC\r\n```\r\n\r\n**drop/take**\r\n```scala\r\nval q = quote {\r\n  query[Person].drop(2).take(1)\r\n}\r\n\r\ndb.run(q)\r\n// SELECT x.id, x.name, x.age FROM Person x LIMIT 1 OFFSET 2\r\n```\r\n\r\n**groupBy**\r\n```scala\r\nval q = quote {\r\n  query[Person].groupBy(p => p.age).map {\r\n    case (age, people) =>\r\n      (age, people.size)\r\n  }\r\n}\r\n\r\ndb.run(q)\r\n// SELECT p.age, COUNT(*) FROM Person p GROUP BY p.age\r\n```\r\n\r\n**union**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => p.age > 18).union(query[Person].filter(p => p.age > 60))\r\n}\r\n\r\ndb.run(q)\r\n// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age > 18 \r\n// UNION SELECT id, name, age FROM Person p1 WHERE p1.age > 60) x\r\n```\r\n\r\n**unionAll/++**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => p.age > 18).unionAll(query[Person].filter(p => p.age > 60))\r\n}\r\n\r\ndb.run(q) \r\n// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age > 18 \r\n// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age > 60) x\r\n\r\nval q2 = quote {\r\n  query[Person].filter(p => p.age > 18) ++ query[Person].filter(p => p.age > 60)\r\n}\r\n\r\ndb.run(q2) \r\n// SELECT x.id, x.name, x.age FROM (SELECT id, name, age FROM Person p WHERE p.age > 18 \r\n// UNION ALL SELECT id, name, age FROM Person p1 WHERE p1.age > 60) x\r\n```\r\n\r\n**aggregation**\r\n```scala\r\nval r = quote {\r\n  query[Person].map(p => p.age)\r\n}\r\n\r\ndb.run(r.min) // SELECT MIN(p.age) FROM Person p\r\ndb.run(r.max) // SELECT MAX(p.age) FROM Person p\r\ndb.run(r.avg) // SELECT AVG(p.age) FROM Person p\r\ndb.run(r.sum) // SELECT SUM(p.age) FROM Person p\r\ndb.run(r.size) // SELECT COUNT(p.age) FROM Person p\r\n```\r\n\r\n**isEmpty/nonEmpty**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter{ p1 => \r\n    query[Person].filter(p2 => p2.id != p1.id && p2.age == p1.age).isEmpty\r\n  }\r\n}\r\n\r\ndb.run(q) \r\n// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE \r\n// NOT EXISTS (SELECT * FROM Person p2 WHERE (p2.id <> p1.id) AND (p2.age = p1.age))\r\n\r\nval q2 = quote {\r\n  query[Person].filter{ p1 => \r\n    query[Person].filter(p2 => p2.id != p1.id && p2.age == p1.age).nonEmpty\r\n  }\r\n}\r\n\r\ndb.run(q2)\r\n// SELECT p1.id, p1.name, p1.age FROM Person p1 WHERE \r\n// EXISTS (SELECT * FROM Person p2 WHERE (p2.id <> p1.id) AND (p2.age = p1.age))\r\n```\r\n\r\n**contains**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => Set(1, 2).contains(p.id))\r\n}\r\n\r\ndb.run(q)\r\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (1, 2)\r\n\r\nval peopleWithContacts = quote {\r\n  query[Person].filter(p => query[Contact].filter(c => c.personId == p.id).nonEmpty)\r\n}\r\nval q2 = quote {\r\n  query[Person].filter(p => peopleWithContacts.contains(p.id))\r\n}\r\n\r\ndb.run(q2)\r\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.id IN (SELECT p1.* FROM Person p1 WHERE EXISTS (SELECT c.* FROM Contact c WHERE c.personId = p1.id))\r\n```\r\n\r\n**distinct**\r\n```scala\r\nval q = quote {\r\n  query[Person].map(p => p.age).distinct\r\n}\r\n\r\ndb.run(q)\r\n// SELECT DISTINCT p.age FROM Person p\r\n```\r\n\r\n**joins**\r\n\r\nIn addition to applicative joins Quill also supports explicit joins (both inner and left/right/full outer joins).\r\n\r\n```scala\r\n\r\nval q = quote {\r\n  query[Person].join(query[Contact]).on((p, c) => c.personId == p.id)\r\n}\r\n\r\ndb.run(q) \r\n// SELECT p.id, p.name, p.age, c.personId, c.phone•\r\n// FROM Person p INNER JOIN Contact c ON c.personId = p.id\r\n\r\nval q = quote {\r\n  query[Person].leftJoin(query[Contact]).on((p, c) => c.personId == p.id)\r\n}\r\n\r\ndb.run(q) \r\n// SELECT p.id, p.name, p.age, c.personId, c.phone•\r\n// FROM Person p LEFT JOIN Contact c ON c.personId = p.id\r\n\r\n```\r\n\r\nThe example joins above cover the simple case. What do you do when a query requires joining more than 2 tables?\r\n\r\nWith Quill the following multi-join queries are equivalent, choose according to preference:\r\n\r\n```scala\r\n\r\ncase class Employer(id: Int, personId: Int, name: String)\r\n\r\nval qFlat = quote {\r\n  for{\r\n    (p,e) <- query[Person].join(query[Employer]).on(_.id == _.personId)\r\n       c  <- query[Contact].leftJoin(_.personId == p.id)\r\n  } yield(p, e, c)\r\n}\r\n\r\nval qNested = quote {\r\n  for{\r\n    ((p,e),c) <-\r\n      query[Person].join(query[Employer]).on(_.id == _.personId)\r\n      .leftJoin(query[Contact]).on(\r\n        _._1.id == _.personId\r\n      )\r\n  } yield(p, e, c)\r\n}\r\n\r\ndb.run(qFlat) \r\ndb.run(qNested) \r\n// SELECT p.id, p.name, p.age, e.id, e.personId, e.name, c.id, c.phone•\r\n// FROM Person p INNER JOIN Employer e ON p.id = e.personId LEFT JOIN Contact c ON c.personId = p.id\r\n\r\n```\r\n\r\n# Query probing #\r\n\r\nQuery probing is an experimental feature that validates queries against the database at compile time, failing the compilation if it is not valid. The query validation does not alter the database state.\r\n\r\nThis feature is disabled by default. To enable it, mix the `QueryProbing` trait to the database configuration:\r\n\r\n```\r\nlazy val db = source(new MySourceConfig(\"configKey\") with QueryProbing)\r\n```\r\n\r\nThe configurations correspondent to the config key must be available at compile time. You can achieve it by adding this line to your project settings:\r\n\r\n```\r\nunmanagedClasspath in Compile += baseDirectory.value / \"src\" / \"main\" / \"resources\"\r\n```\r\n\r\nIf your project doesn't have a standard layout, e.g. a play project, you should configure the path to point to the folder that contains your config file. \r\n\r\n# Actions #\r\n\r\nDatabase actions are defined using quotations as well. These actions don't have a collection-like API but rather a custom DSL to express inserts, deletes and updates.\r\n\r\n  Note: Actions receive a `List` as they are batched by default. And also it can recieve a `single` item as well.\r\n\r\n**insert**\r\n```scala\r\nval a = quote(query[Contact].insert)\r\n\r\ndb.run(a)(List(Contact(999, \"+1510488988\"))) \r\n// INSERT INTO Contact (personId,phone) VALUES (?, ?)\r\ndb.run(a)(Contact(999, \"+1510488988\"))\r\n// INSERT INTO Contact (personId,phone) VALUES (?, ?)\r\n```\r\n\r\nIt is also possible to insert specific columns:\r\n\r\n```scala\r\nval a = quote {\r\n  (personId: Int, phone: String) =>\r\n    query[Contact].insert(_.personId -> personId, _.phone -> phone)\r\n}\r\n\r\ndb.run(a)(List((999, \"+1510488988\"))) \r\n// INSERT INTO Contact (personId,phone) VALUES (?, ?)\r\n```\r\n\r\nOr column queries:\r\n\r\n```scala\r\nval a = quote {\r\n  (id: Int) =>\r\n    query[Person].insert(_.id -> id, _.age -> query[Person].map(p => p.age).max)\r\n}\r\n\r\ndb.run(a)(List(999)) \r\n// INSERT INTO Person (id,age) VALUES (?, (SELECT MAX(p.age) FROM Person p))\r\n```\r\n\r\n**update**\r\n```scala\r\nval a = quote {\r\n  query[Person].filter(_.id == 999).update\r\n}\r\n\r\ndb.run(a)(List(Person(999, \"John\", 22)))\r\n// UPDATE Person SET id = ?, name = ?, age = ? WHERE id = 999\r\n```\r\n\r\nUsing specific columns:\r\n\r\n```scala\r\nval a = quote {\r\n  (id: Int, age: Int) =>\r\n    query[Person].filter(p => p.id == id).update(_.age -> age)\r\n}\r\n\r\ndb.run(a)(List((999, 18)))\r\n// UPDATE Person SET age = ? WHERE id = ?\r\n```\r\n\r\nUsing columns as part of the update:\r\n\r\n```scala\r\nval a = quote {\r\n  (id: Int) =>\r\n    query[Person].filter(p => p.id == id).update(p => p.age -> (p.age + 1))\r\n}\r\n\r\ndb.run(a)(List(999))\r\n// UPDATE Person SET age = (age + 1) WHERE id = ?\r\n```\r\n\r\nUsing column a query:\r\n\r\n```scala\r\nval a = quote {\r\n  (id: Int) =>\r\n    query[Person].filter(p => p.id == id).update(_.age -> query[Person].map(p => p.age).max)\r\n}\r\n\r\ndb.run(a)(List(999))\r\n// UPDATE Person SET age = (SELECT MAX(p.age) FROM Person p) WHERE id = ?\r\n```\r\n\r\n**delete**\r\n```scala\r\nval a = quote {\r\n  query[Person].filter(p => p.name == \"\").delete\r\n}\r\n\r\ndb.run(a) \r\n// DELETE FROM Person WHERE name = ''\r\n```\r\n\r\n# Implicit query #\r\n\r\nQuill provides implicit conversions from case class companion objects to `query[T]` through an extra import:\r\n\r\n```scala\r\nimport io.getquill.ImplicitQuery._\r\n\r\nval q = quote {\r\n  for {\r\n    p <- Person if(p.id == 999)\r\n    c <- Contact if(c.personId == p.id)\r\n  } yield {\r\n    (p.name, c.phone)\r\n  }\r\n}\r\n\r\ndb.run(q) \r\n// SELECT p.name, c.phone FROM Person p, Contact c WHERE (p.id = 999) AND (c.personId = p.id)\r\n```\r\n\r\nNote the usage of `Person` and `Contact` instead of `query[Person]` and `query[Contact]`.\r\n\r\n# SQL-specific operations #\r\n\r\nSome operations are sql-specific and not provided with the generic quotation mechanism. The `io.getquill.sources.sql.ops` package has some implicit classes for this kind of operations:\r\n\r\n**like**\r\n\r\n```scala\r\nimport io.getquill.sources.sql.ops._\r\n\r\nval q = quote {\r\n  query[Person].filter(p => p.name like \"%John%\")\r\n}\r\ndb.run(q)\r\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.name like '%John%'\r\n```\r\n\r\n# Cassandra-specific operations #\r\n\r\nThe cql-specific operations are provided by the following import:\r\n\r\n```scala\r\nimport io.getquill.sources.cassandra.ops._\r\n```\r\n\r\nThe cassandra package also offers a mirror source:\r\n\r\n```scala\r\nimport io.getquill._\r\n\r\nlazy val db = source(new CassandraMirrorSourceConfig(\"testSource\"))\r\n```\r\n\r\nSupported operations:\r\n\r\n**allowFiltering**\r\n\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => p.age > 10).allowFiltering\r\n}\r\ndb.run(q)\r\n// SELECT id, name, age FROM Person WHERE age > 10 ALLOW FILTERING\r\n```\r\n\r\n**ifNotExists**\r\n```scala\r\nval q = quote {\r\n  query[Person].insert(_.age -> 10, _.name -> \"John\").ifNotExists\r\n}\r\ndb.run(q)\r\n// INSERT INTO Person (age,name) VALUES (10, 'John') IF NOT EXISTS\r\n```\r\n\r\n**ifExists**\r\n```scala\r\nval q = quote {\r\n  query[Person].filter(p => p.name == \"John\").delete.ifExists\r\n}\r\ndb.run(q)\r\n// DELETE FROM Person WHERE name = 'John' IF EXISTS\r\n```\r\n\r\n**usingTimestamp**\r\n```scala\r\nval q1 = quote {\r\n  query[Person].insert(_.age -> 10, _.name -> \"John\").usingTimestamp(99)\r\n}\r\ndb.run(q1)\r\n// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99\r\n\r\nval q2 = quote {\r\n  query[Person].usingTimestamp(99).update(_.age -> 10)\r\n}\r\ndb.run(q2)\r\n// UPDATE Person USING TIMESTAMP 99 SET age = 10\r\n```\r\n\r\n**usingTtl**\r\n```scala\r\nval q1 = quote {\r\n  query[Person].insert(_.age -> 10, _.name -> \"John\").usingTtl(11)\r\n}\r\ndb.run(q1)\r\n// INSERT INTO Person (age,name) VALUES (10, 'John') USING TTL 11\r\n\r\nval q2 = quote {\r\n  query[Person].usingTtl(11).update(_.age -> 10)\r\n}\r\ndb.run(q2)\r\n// UPDATE Person USING TTL 11 SET age = 10\r\n\r\nval q3 = quote {\r\n  query[Person].usingTtl(11).filter(_.name == \"John\").delete\r\n}\r\ndb.run(q3)  \r\n// DELETE FROM Person USING TTL 11 WHERE name = 'John'\r\n```\r\n\r\n**using**\r\n```scala\r\nval q1 = quote {\r\n  query[Person].insert(_.age -> 10, _.name -> \"John\").using(ts = 99, ttl = 11)\r\n}\r\ndb.run(q1)\r\n// INSERT INTO Person (age,name) VALUES (10, 'John') USING TIMESTAMP 99 AND TTL 11\r\n\r\nval q2 = quote {\r\n  query[Person].using(ts = 99, ttl = 11).update(_.age -> 10)\r\n}\r\ndb.run(q2)\r\n// UPDATE Person USING TIMESTAMP 99 AND TTL 11 SET age = 10\r\n\r\nval q3 = quote {\r\n  query[Person].using(ts = 99, ttl = 11).filter(_.name == \"John\").delete\r\n}\r\ndb.run(q3)\r\n// DELETE FROM Person USING TIMESTAMP 99 AND TTL 11 WHERE name = 'John'\r\n```\r\n\r\n**ifCond**\r\n```scala\r\nval q1 = quote {\r\n  query[Person].update(_.age -> 10).ifCond(_.name == \"John\")\r\n}\r\ndb.run(q1)\r\n// UPDATE Person SET age = 10 IF name = 'John'\r\n\r\nval q2 = quote {\r\n  query[Person].filter(_.name == \"John\").delete.ifCond(_.age == 10)\r\n}\r\ndb.run(q2)\r\n// DELETE FROM Person WHERE name = 'John' IF age = 10\r\n```\r\n\r\n**delete column**\r\n```scala\r\nval q = quote {\r\n  query[Person].map(p => p.age).delete\r\n}\r\ndb.run(q)\r\n// DELETE p.age FROM Person\r\n```\r\n\r\n# Dynamic queries #\r\n\r\nQuill's default operation mode is compile-time, but there are queries that have their structure defined only at runtime. Quill automatically falls back to runtime normalization and query generation if the query's structure is not static. Example:\r\n\r\n```scala\r\nimport io.getquill._\r\n\r\nlazy val db = source(new MirrorSourceConfig(\"testSource\"))\r\n\r\nsealed trait QueryType\r\ncase object Minor extends QueryType\r\ncase object Senior extends QueryType\r\n\r\ndef people(t: QueryType): Quoted[Query[Person]] =\r\n  t match {\r\n    case Minor => quote {\r\n      query[Person].filter(p => p.age < 18)\r\n    }\r\n    case Senior => quote {\r\n      query[Person].filter(p => p.age > 65)\r\n    }\r\n  }\r\n\r\ndb.run(people(Minor)) \r\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.age < 18\r\n\r\ndb.run(people(Senior)) \r\n// SELECT p.id, p.name, p.age FROM Person p WHERE p.age > 65\r\n```\r\n\r\n# Extending quill #\r\n\r\n## Infix ##\r\n\r\nInfix is a very flexible mechanism to use non-supported features without having to use plain queries in the target language. It allows insertion of arbitrary strings within quotations.\r\n\r\nFor instance, quill doesn't support the `FOR UPDATE` SQL feature. It can still be used through infix and implicit classes:\r\n\r\n```scala\r\nimplicit class ForUpdate[T](q: Query[T]) {\r\n  def forUpdate = quote(infix\"$q FOR UPDATE\".as[Query[T]])\r\n}\r\n\r\nval a = quote {\r\n  query[Person].filter(p => p.age < 18).forUpdate\r\n}\r\n\r\ndb.run(a)\r\n// SELECT p.id, p.name, p.age FROM (SELECT * FROM Person p WHERE p.age < 18 FOR UPDATE) p\r\n```\r\n\r\nThe `forUpdate` quotation can be reused for multiple queries.\r\n\r\nThe same approach can be used for `RETURNING ID`:\r\n\r\n```scala\r\nimplicit class ReturningId[T](a: Action[T]) {\r\n  def returningId = quote(infix\"$a RETURNING ID\".as[Action[T]])\r\n}\r\n\r\nval a = quote {\r\n  query[Person].insert(_.name -> \"John\", _.age -> 21).returningId\r\n}\r\n\r\ndb.run(a)\r\n// INSERT INTO Person (name,age) VALUES ('John', 21) RETURNING ID\r\n```\r\n\r\nA custom database function can also be used through infix:\r\n\r\n```scala\r\nval myFunction = quote {\r\n  (i: Int) => infix\"MY_FUNCTION($i)\".as[Int]\r\n}\r\n\r\nval q = quote {\r\n  query[Person].map(p => myFunction(p.age))\r\n}\r\n\r\ndb.run(q) \r\n// SELECT MY_FUNCTION(p.age) FROM Person p\r\n```\r\n\r\n## Custom encoding ##\r\n\r\nQuill uses `Encoder`s to encode query inputs and `Decoder`s to read values returned by queries. The library provides a few built-in encodings and two mechanisms to define custom encodings: mapped encoding and raw encoding.\r\n\r\n### Mapped Encoding ###\r\n\r\nIf the correspondent database type is already supported, use `mappedEncoding`. In this example, `String` is already supported by Quill and the `UUID` encoding from/to `String` is defined through mapped encoding:\r\n\r\n```scala\r\nimport java.util.UUID\r\n\r\nimplicit val encodeUUID = mappedEncoding[UUID, String](_.toString)\r\nimplicit val decodeUUID = mappedEncoding[String, UUID](UUID.fromString(_))\r\n```\r\n\r\n### Raw Encoding ###\r\n\r\nIf the database type is not supported by Quill, it is possible to provide \"raw\" encoders and decoders:\r\n\r\n```\r\nimport io.getquill.sources.mirror.Row\r\n\r\nimplicit val uuidEncoder = \r\n  db.encoder[UUID] {\r\n    ??? // database-specific implementation\r\n  }\r\n\r\nimplicit val uuidDecoder = \r\n  db.decoder[UUID] {\r\n    ??? // database-specific implementation\r\n  }\r\n```\r\n\r\n### Wrapped types ###\r\n\r\nQuill also supports encoding of \"wrapped types\". Just extend the `WrappedValue` trait and Quill will automatically encode the underlying primitive type.\r\n\r\n```scala\r\nimport io.getquill.sources._\r\n\r\ncase class UserId(value: Int) extends AnyVal with WrappedValue[Int]\r\ncase class User(id: UserId, name: String)\r\n\r\nval q = quote {\r\n  (id: UserId) => for {\r\n    u <- query[User] if u.id == id\r\n  } yield u\r\n}\r\ndb.run(q)(UserId(1))\r\n\r\n// SELECT u.id, u.name FROM User u WHERE (u.id = 1)\r\n```\r\n\r\n# SQL Sources #\r\n\r\nSources represent the database and provide an execution interface for queries. Example:\r\n\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\nimport io.getquill.sources.sql.idiom.MySQLDialect\r\n\r\nlazy val db = source(new JdbcSourceConfig[MySQLDialect, SnakeCase](\"db\"))\r\n```\r\n\r\n## Dialect ##\r\n\r\nThe SQL dialect to be used by the source is defined by the first type parameter. Some source types are specific to a database and thus not require it.\r\n\r\nQuill has three built-in dialects:\r\n\r\n- `io.getquill.sources.sql.idiom.H2Dialect`\r\n- `io.getquill.sources.sql.idiom.MySQLDialect`\r\n- `io.getquill.sources.sql.idiom.PostgresDialect`\r\n\r\n## Naming strategy ##\r\n\r\nThe second type parameter defines the naming strategy to be used when translating identifiers (table and column names) to SQL. \r\n\r\n\r\n|           strategy                  |          example              |\r\n|-------------------------------------|-------------------------------|\r\n| `io.getquill.naming.Literal`        | some_ident  -> some_ident     |\r\n| `io.getquill.naming.Escape`         | some_ident  -> \"some_ident\"   |\r\n| `io.getquill.naming.UpperCase`      | some_ident  -> SOME_IDENT     |\r\n| `io.getquill.naming.LowerCase`      | SOME_IDENT  -> some_ident     |\r\n| `io.getquill.naming.SnakeCase`      | someIdent   -> some_ident     |\r\n| `io.getquill.naming.CamelCase`      | some_ident  -> someIdent      |\r\n| `io.getquill.naming.MysqlEscape`    | some_ident  -> \\`some_ident\\` |\r\n| `io.getquill.naming.PostgresEscape` | $some_ident -> $some_ident    |\r\n\r\nMultiple transformations can be defined using mixin. For instance, the naming strategy \r\n\r\n```SnakeCase with UpperCase```\r\n\r\nproduces the following transformation:\r\n\r\n```someIdent -> SOME_IDENT```\r\n\r\nThe transformations are applied from left to right.\r\n\r\n## Configuration ##\r\n\r\nThe string passed to the source configuration is used as the key to obtain configurations using the [typesafe config](http://github.com/typesafehub/config) library.\r\n\r\nAdditionally, any member of a source configuration can be overriden. Example:\r\n\r\n```\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\nimport io.getquill.sources.sql.idiom.MySQLDialect\r\n\r\nlazy val db = source(new JdbcSourceConfig[MySQLDialect, SnakeCase](\"db\") {\r\n  override def dataSource = ??? // create the datasource manually\r\n})\r\n```\r\n\r\n### quill-jdbc ###\r\n\r\nQuill uses [HikariCP](https://github.com/brettwooldridge/HikariCP) for connection pooling. Please refer to HikariCP's [documentation](https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby) for a detailed explanation of the available configurations.\r\n\r\nNote that there are `dataSource` configurations, that go under `dataSource`, like `user` and `password`, but some pool settings may go under the root config, like `connectionTimeout`.\r\n\r\n**MySQL**\r\n\r\nsbt dependencies\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"mysql\" % \"mysql-connector-java\" % \"5.1.36\",\r\n  \"io.getquill\" %% \"quill-jdbc\" % \"0.4.1\"\r\n)\r\n```\r\n\r\nsource definition\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\nimport io.getquill.sources.sql.idiom.MySQLDialect\r\n\r\nlazy val db = source(new JdbcSourceConfig[MySQLDialect, SnakeCase](\"db\"))\r\n```\r\n\r\napplication.properties\r\n```\r\ndb.dataSourceClassName=com.mysql.jdbc.jdbc2.optional.MysqlDataSource\r\ndb.dataSource.url=jdbc:mysql://host/database\r\ndb.dataSource.user=root\r\ndb.dataSource.password=root\r\ndb.dataSource.cachePrepStmts=true\r\ndb.dataSource.prepStmtCacheSize=250\r\ndb.dataSource.prepStmtCacheSqlLimit=2048\r\ndb.connectionTimeout=30000\r\n```\r\n\r\n**Postgres**\r\n\r\nsbt dependencies\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"org.postgresql\" % \"postgresql\" % \"9.4-1206-jdbc41\",\r\n  \"io.getquill\" %% \"quill-jdbc\" % \"0.4.1\"\r\n)\r\n```\r\n\r\nsource definition\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\nimport io.getquill.sources.sql.idiom.PostgresDialect\r\n\r\nlazy val db = source(new JdbcSourceConfig[PostgresDialect, SnakeCase](\"db\"))\r\n```\r\n\r\napplication.properties\r\n```\r\ndb.dataSourceClassName=org.postgresql.ds.PGSimpleDataSource\r\ndb.dataSource.user=root\r\ndb.dataSource.password=root\r\ndb.dataSource.databaseName=database\r\ndb.dataSource.portNumber=5432\r\ndb.dataSource.serverName=host\r\ndb.connectionTimeout=30000\r\n```\r\n\r\n### quill-async ###\r\n\r\n**MySQL Async**\r\n\r\nsbt dependencies\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"io.getquill\" %% \"quill-async\" % \"0.4.1\"\r\n)\r\n```\r\n\r\nsource definition\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\n\r\nlazy val db = source(new MysqlAsyncSourceConfig[SnakeCase](\"db\"))\r\n```\r\n\r\napplication.properties\r\n```\r\ndb.host=host\r\ndb.port=3306\r\ndb.user=root\r\ndb.password=root\r\ndb.database=database\r\ndb.poolMaxQueueSize=4\r\ndb.poolMaxObjects=4\r\ndb.poolMaxIdle=999999999\r\ndb.poolValidationInterval=100\r\n```\r\n\r\n**Postgres Async**\r\n\r\nsbt dependencies\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"io.getquill\" %% \"quill-async\" % \"0.4.1\"\r\n)\r\n```\r\n\r\nsource definition\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\n\r\nlazy val db = source(new PostgresAsyncSourceConfig[SnakeCase](\"db\"))\r\n```\r\n\r\napplication.properties\r\n```\r\ndb.host=host\r\ndb.port=5432\r\ndb.user=root\r\ndb.password=root\r\ndb.database=database\r\ndb.poolMaxQueueSize=4\r\ndb.poolMaxObjects=4\r\ndb.poolMaxIdle=999999999\r\ndb.poolValidationInterval=100\r\n```\r\n\r\n### quill-finagle-mysql ###\r\n\r\nsbt dependencies\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"io.getquill\" %% \"quill-finagle-mysql\" % \"0.4.1\"\r\n)\r\n```\r\n\r\nsource definition\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\n\r\nlazy val db = source(new FinagleMysqlSourceConfig[SnakeCase](\"db\"))\r\n```\r\n\r\napplication.properties\r\n```\r\ndb.dest=localhost:3306\r\ndb.user=root\r\ndb.password=root\r\ndb.database=database\r\ndb.pool.watermark.low=0\r\ndb.pool.watermark.high=10\r\ndb.pool.idleTime=5 # seconds\r\ndb.pool.bufferSize=0\r\ndb.pool.maxWaiters=2147483647\r\n```\r\n\r\n# Cassandra Sources #\r\n\r\nsbt dependencies\r\n```\r\nlibraryDependencies ++= Seq(\r\n  \"io.getquill\" %% \"quill-cassandra\" % \"0.4.1\"\r\n)\r\n```\r\n\r\n**synchronous source**\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\n\r\nlazy val db = source(new CassandraSyncSourceConfig[SnakeCase](\"db\"))\r\n```\r\n\r\n**asynchronous source**\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\n\r\nlazy val db = source(new CassandraAsyncSourceConfig[SnakeCase](\"db\"))\r\n```\r\n\r\n**stream source**\r\n```scala\r\nimport io.getquill._\r\nimport io.getquill.naming.SnakeCase\r\n\r\nlazy val db = source(new CassandraStreamSourceConfig[SnakeCase](\"db\"))\r\n```\r\n\r\nThe configurations are set using runtime reflection on the [`Cluster.builder`](https://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/Cluster.Builder.html) instance. It is possible to set nested structures like `queryOptions.consistencyLevel`, use enum values like `LOCAL_QUORUM`, and set multiple parameters like in `credentials`.\r\n\r\napplication.properties\r\n```\r\ndb.keyspace=quill_test\r\ndb.preparedStatementCacheSize=1000\r\ndb.session.contactPoint=127.0.0.1\r\ndb.session.queryOptions.consistencyLevel=LOCAL_QUORUM\r\ndb.session.withoutMetrics=true\r\ndb.session.withoutJMXReporting=false\r\ndb.session.credentials.0=root\r\ndb.session.credentials.1=pass\r\ndb.session.maxSchemaAgreementWaitSeconds=1\r\ndb.session.addressTranslater=com.datastax.driver.core.policies.IdentityTranslater\r\n```\r\n\r\n# Slick comparison #\r\n\r\nPlease refer to [SLICK.md](https://github.com/getquill/quill/blob/master/SLICK.md) for a detailed comparison between Quill and Slick.\r\n\r\n# Cassandra libraries comparison #\r\n\r\nPlease refer to [CASSANDRA.md](https://github.com/getquill/quill/blob/master/CASSANDRA.md) for a detailed comparison between Quill and other main alternatives for interaction with Cassandra in Scala.\r\n\r\n# Maintainers #\r\n\r\n- @fwbrasil\r\n- @godenji\r\n- @gustavoamigo\r\n- @jilen\r\n- @lvicentesanchez\r\n\r\nYou can notify all maintainers using the handle `@getquill/maintainers`.\r\n\r\n# Acknowledgments #\r\n\r\nThe project was created having Philip Wadler's talk [\"A practical theory of language-integrated query\"](http://www.infoq.com/presentations/theory-language-integrated-query) as its initial inspiration. The development was heavily influenced by the following papers:\r\n\r\n* [A Practical Theory of Language-Integrated Query](http://homepages.inf.ed.ac.uk/slindley/papers/practical-theory-of-linq.pdf)\r\n* [Everything old is new again: Quoted Domain Specific Languages](http://homepages.inf.ed.ac.uk/wadler/papers/qdsl/qdsl.pdf)\r\n* [The Flatter, the Better](http://db.inf.uni-tuebingen.de/staticfiles/publications/the-flatter-the-better.pdf)\r\n\r\n# License #\r\n\r\nSee the [LICENSE](https://github.com/getquill/quill/blob/master/LICENSE.txt) file for details.\r\n","google":"UA-65451450-1","note":"Don't delete this file! It's used internally to help with page regeneration."}